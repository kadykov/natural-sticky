<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snap Eagerness 1.0 - Natural Sticky</title>
    <link rel="stylesheet" href="style.css" />
    <style>
      body {
        margin: 0;
        font-size: 14px;
      }
      .content {
        padding: 1rem;
      }
      .sticky-header {
        background: #28a745;
        color: white;
        padding: 0.5rem 1rem;
        margin: 0;
        font-size: 1rem;
      }
      .sticky-header h1 {
        margin: 0;
        font-size: 1.2rem;
      }
    </style>
  </head>
  <body>
    <header class="sticky-header">
      <h1>Balanced (1.0)</h1>
    </header>

    <main>
      <div class="content">
        <h2>Balanced Behavior (snapEagerness: 1.0) - Default</h2>
        <p>
          <strong>Configuration:</strong> <code>{ snapEagerness: 1.0 }</code> or
          simply <code>naturalStickyTop(element)</code>
        </p>
        <p>
          This is the recommended default value that balances natural movement
          with gap prevention through subtle scroll prediction.
        </p>

        <div
          style="
            background: #d4edda;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin: 1rem 0;
          "
        >
          <p style="margin: 0; color: #155724">
            ‚öñÔ∏è <strong>Balanced approach:</strong> This value predicts one
            scroll step ahead, switching to sticky just before gaps would
            appear, while maintaining natural feel.
          </p>
        </div>

        <h3>üéØ Why This is the Default</h3>
        <p>
          After extensive testing across different browsers, devices, and user
          behaviors, snapEagerness: 1.0 emerged as the sweet spot:
        </p>

        <ul>
          <li>
            ‚úÖ <strong>Natural feel preserved:</strong> Movement still feels
            connected to your scrolling
          </li>
          <li>
            ‚úÖ <strong>Gap prevention:</strong> Eliminates most visual artifacts
            without being intrusive
          </li>
          <li>
            ‚úÖ <strong>Cross-browser reliability:</strong> Works consistently
            across all modern browsers
          </li>
          <li>
            ‚úÖ <strong>Mobile-friendly:</strong> Handles momentum scrolling
            gracefully
          </li>
          <li>
            ‚úÖ <strong>Performance optimized:</strong> Minimal prediction
            overhead
          </li>
        </ul>

        <h3>üìê The Prediction Algorithm</h3>
        <p>Here's how the one-step prediction works in the source code:</p>

        <div
          style="
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin: 1.5rem 0;
            overflow-x: auto;
          "
        >
          <pre><code>const handleScroll = () => {
  const currentScrollY = window.scrollY;
  const elementRect = element.getBoundingClientRect();
  
  // Calculate scroll velocity (distance moved this frame)
  const scrollVelocity = currentScrollY - lastScrollY;
  
  // Predict where the element will be after one more scroll step
  const predictedTop = elementRect.top - snapEagerness * scrollVelocity;
  //                                      ‚Üë
  //                            snapEagerness: 1.0 = predict 1 step ahead
  
  // Switch to sticky when prediction shows element would be at/past top
  if (mode === 'relative' && predictedTop >= 0) {
    mode = 'sticky';
    element.style.position = 'sticky';
    element.style.top = '0';
  }
}</code></pre>
        </div>

        <h3>üî¨ Technical Deep Dive</h3>
        <p>The magic happens in the prediction calculation:</p>
        <ul>
          <li>
            <strong>Scroll Velocity:</strong>
            <code>currentScrollY - lastScrollY</code> gives us the distance
            moved in this frame
          </li>
          <li>
            <strong>Prediction:</strong>
            <code>elementRect.top - 1.0 * scrollVelocity</code> estimates where
            the element will be next frame
          </li>
          <li>
            <strong>Decision Point:</strong> When predicted position ‚â• 0, we
            know the element is about to reach the top
          </li>
          <li>
            <strong>Smooth Transition:</strong> Switch to sticky mode just
            before the gap would appear
          </li>
        </ul>

        <h3>üöÄ When to Use the Default (1.0)</h3>
        <p>This balanced approach is ideal for:</p>
        <ul>
          <li>
            <strong>General-purpose applications</strong> - Works well for most
            use cases
          </li>
          <li>
            <strong>Mixed device targeting</strong> - Handles both desktop and
            mobile gracefully
          </li>
          <li>
            <strong>Unknown user behavior</strong> - Accommodates both slow and
            fast scrollers
          </li>
          <li>
            <strong>Production applications</strong> - Battle-tested reliability
          </li>
          <li>
            <strong>When in doubt</strong> - Safe choice that rarely disappoints
          </li>
        </ul>

        <h3>üì± Mobile Optimization</h3>
        <p>
          The 1.0 value is specifically tuned for mobile momentum scrolling:
        </p>
        <ul>
          <li>Handles the initial fast scroll phase</li>
          <li>Adapts during the deceleration phase</li>
          <li>Prevents gaps during quick flick gestures</li>
          <li>Maintains natural feel during slow drag scrolling</li>
        </ul>

        <div
          style="
            background: #fff3cd;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin: 1rem 0;
          "
        >
          <p style="margin: 0; color: #856404">
            <strong>Pro tip:</strong> If you're unsure which snapEagerness value
            to choose, start with 1.0 and only change it if you have specific
            issues to solve.
          </p>
        </div>

        <h3>üîç Testing This Configuration</h3>
        <p>Try these specific scroll patterns to see the balanced behavior:</p>
        <ul>
          <li>
            <strong>Slow scrolling:</strong> Should feel perfectly natural, just
            like 0.0
          </li>
          <li>
            <strong>Medium speed:</strong> Notice the smooth transitions with no
            gaps
          </li>
          <li>
            <strong>Fast scrolling:</strong> Prediction prevents gaps while
            maintaining connection
          </li>
          <li>
            <strong>Direction changes:</strong> Quick reversal should be handled
            smoothly
          </li>
          <li>
            <strong>Mobile flick:</strong> (If on mobile) Try momentum scrolling
            in both directions
          </li>
        </ul>

        <h3>üìä Comparison with Other Values</h3>
        <p>Understanding where 1.0 fits in the spectrum:</p>
        <ul>
          <li>
            <strong>snapEagerness: 0.0</strong> - Pure natural (may show gaps)
          </li>
          <li>
            <strong>snapEagerness: 1.0</strong> ‚Üê You are here (Balanced
            default)
          </li>
          <li>
            <strong>snapEagerness: 2.0</strong> - More aggressive gap prevention
          </li>
          <li>
            <strong>snapEagerness: 3.0</strong> - Intentional "magnetic"
            snapping effect
          </li>
        </ul>

        <h3>‚ö° Performance Characteristics</h3>
        <p>The balanced approach offers optimal performance:</p>
        <ul>
          <li>
            <strong>Minimal CPU overhead:</strong> Single-step prediction is
            computationally light
          </li>
          <li>
            <strong>Smooth frame rates:</strong> No complex calculations per
            scroll event
          </li>
          <li>
            <strong>Memory efficient:</strong> Simple state tracking without
            history buffers
          </li>
          <li>
            <strong>Battery friendly:</strong> Especially important for mobile
            devices
          </li>
        </ul>

        <p>
          Continue scrolling to experience how this balanced approach handles
          various scroll patterns. The goal is for the behavior to feel so
          natural that you don't think about it - the header should just "work"
          the way you expect.
        </p>

        <div
          style="
            height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #d4edda;
            border-radius: 8px;
            margin: 2rem 0;
          "
        >
          <p style="text-align: center; color: #155724">
            <strong>The Sweet Spot in Action!</strong><br />
            Notice how natural this feels while being completely reliable.<br />
            This is why 1.0 is the default choice.
          </p>
        </div>
      </div>
    </main>

    <script src="../dist/natural-sticky.top.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const header = document.querySelector('.sticky-header');
        if (header && window.naturalStickyTop) {
          window.naturalStickyTop(header, { snapEagerness: 1.0 });
        }
      });
    </script>
    <script src="drag-scroll.js"></script>
  </body>
</html>
