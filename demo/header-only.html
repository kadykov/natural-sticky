<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Header Only Demo - Natural Sticky</title>
    <link rel="stylesheet" href="style.css" />
    <style>
      .sticky-header {
        background: linear-gradient(
          135deg,
          #28a745 0%,
          #20c997 100%
        ) !important;
      }
    </style>
  </head>
  <body>
    <header class="sticky-header">
      <h1>Natural Sticky Header</h1>
    </header>

    <main>
      <div class="content">
        <h2>Scroll Down to See the Natural Hide Effect</h2>
        <p>
          You know what? Lorem ipsum is boring. Instead of meaningless
          placeholder text, let's show you the actual TypeScript source code
          that makes this header behavior work!
        </p>

        <div
          style="
            background: #e3f2fd;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            margin: 1rem 0;
          "
        >
          <p style="margin: 0; color: #1565c0">
            üí° <strong>Pro tip:</strong> Try clicking and dragging to scroll!
            This gives you precise control over scroll speed and direction, just
            like on mobile devices.
          </p>
        </div>

        <p>
          <strong>Fun fact:</strong> This header uses the default settings:
          <code>snapEagerness: 1.0</code> and <code>scrollThreshold: 0</code>.
          This entire script is only <strong>1.0KB minified</strong> and has
          <strong>zero dependencies</strong>. Pure TypeScript compiled to
          vanilla JavaScript.
        </p>

        <h3>üîç The Magic Behind This Header Animation</h3>
        <div
          style="
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            margin: 1.5rem 0;
            overflow-x: auto;
          "
        >
          <pre><code>/**
 * Attaches a natural hide/show behavior to a sticky element placed at the top.
 * 
 * @param element - The HTML element to make naturally sticky
 * @param options - Configuration options
 * @param options.snapEagerness - How eagerly element snaps into sticky position (default: 1)
 * @param options.scrollThreshold - Minimum scroll speed to trigger natural scroll-in effect (default: 0)
 */
export function naturalStickyTop(element: HTMLElement, options?: { 
  snapEagerness?: number; 
  scrollThreshold?: number 
}) {
  let lastScrollY = window.scrollY;
  let isSticky = false;
  let isHeaderAtTop = true;
  const snapEagerness = options?.snapEagerness ?? 1;
  const scrollThreshold = options?.scrollThreshold ?? 0;

  const handleScroll = () => {
    const currentScrollY = window.scrollY;
    const elementRect = element.getBoundingClientRect();
    const scrollStep = currentScrollY - lastScrollY;
    const isElementVisible = elementRect.bottom > 0 && elementRect.top < window.innerHeight;

    // Handle all relative mode logic first
    if (!isSticky) {
      // First priority: Check if element should switch to sticky
      // Predict where element will be on next scroll event to avoid visual gaps
      if (elementRect.top - snapEagerness * scrollStep >= 0) {
        isSticky = true;
        isHeaderAtTop = false;
        element.style.position = 'sticky';
        element.style.top = '0';
      }
      // Second priority: Check if scrolling up with enough speed to trigger scroll-in effect
      else if (-scrollStep >= scrollThreshold && !isElementVisible) {
        isHeaderAtTop = false;
        element.style.position = 'relative';
        // Position element just above viewport so it scrolls into view naturally
        element.style.top = `${currentScrollY - element.offsetHeight}px`;
      }
      // Third priority: When header becomes invisible, move it to top of document
      else if (!isHeaderAtTop && !isElementVisible) {
        isHeaderAtTop = true;
        element.style.position = 'relative';
        element.style.top = '0px';
      }
    }
    // Handle sticky mode logic - release from sticky when scrolling down
    else if (scrollStep > 0) {
      isSticky = false;
      element.style.position = 'relative';
      // Position element at current scroll position so it moves naturally with content
      element.style.top = `${currentScrollY}px`;
    }

    lastScrollY = currentScrollY > 0 ? currentScrollY : 0;
  };

  handleScroll();
  window.addEventListener('scroll', handleScroll, { passive: true });

  return { destroy: () => window.removeEventListener('scroll', handleScroll) };
}</code></pre>
        </div>

        <p>
          Pretty neat, right? The key insight is that instead of using CSS
          transitions or JavaScript animations, we let the browser's natural
          scrolling do all the work. When you scroll down, the header just goes
          along for the ride. When you scroll up, we position it just above the
          viewport so it naturally scrolls back into view.
        </p>

        <p>Keep scrolling to see more of how this works...</p>

        <h3>üéØ How It Works - The Natural Approach</h3>
        <p>
          Traditional sticky headers often use slide animations that can feel
          jarring and distracting:
        </p>
        <ul style="color: #dc3545">
          <li>‚ùå Sudden appearance/disappearance that breaks focus</li>
          <li>‚ùå Fixed animation timing that doesn't match scroll speed</li>
          <li>‚ùå Can cause layout shifts and visual interruptions</li>
          <li>‚ùå Often require heavy animation libraries</li>
          <li>‚ùå Trigger-based animations feel disconnected from user input</li>
        </ul>

        <p>
          Our natural approach is different - it's designed to be
          <strong>less distracting</strong>:
        </p>
        <ul style="color: #28a745">
          <li>‚úÖ Elements move with the natural scroll flow</li>
          <li>‚úÖ Animation speed matches your scroll speed perfectly</li>
          <li>‚úÖ No jarring transitions or layout shifts</li>
          <li>‚úÖ Feels intuitive and unobtrusive - doesn't break user focus</li>
          <li>
            ‚úÖ Movement feels like part of the content, not a separate animation
          </li>
          <li>‚úÖ Only 1.0KB with zero dependencies</li>
        </ul>

        <h3>‚öôÔ∏è The Three States Explained</h3>
        <p>The header operates in three distinct modes:</p>

        <div
          style="
            background: #e3f2fd;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
          "
        >
          <strong>1. Sticky Mode:</strong> <code>position: sticky; top: 0</code
          ><br />
          Header is visible and sticks to the top of the viewport
        </div>

        <div
          style="
            background: #f3e5f5;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
          "
        >
          <strong>2. Released Mode (scrolling down):</strong>
          <code>position: relative; top: currentScrollY</code><br />
          Header flows naturally with the content as you scroll down
        </div>

        <div
          style="
            background: #e8f5e8;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
          "
        >
          <strong>3. Preparation Mode (scrolling up):</strong>
          <code>position: relative; top: currentScrollY - elementHeight</code
          ><br />
          Header is positioned just above the viewport, ready to scroll into
          view
        </div>

        <p>
          The secret sauce is in the positioning logic. When you scroll down, we
          switch from <code>position: sticky</code> to
          <code>position: relative</code> and set the top position to the
          current scroll position. This makes the element flow naturally with
          the content as you scroll down.
        </p>

        <p>
          When you scroll back up and the element isn't visible yet, we position
          it just above the viewport. As you continue scrolling up, it naturally
          comes into view, and once it reaches the top, we switch it back to
          <code>position: sticky</code>.
        </p>

        <h3>üåê Browser Compatibility</h3>
        <p>
          Works in all modern browsers that support
          <code>position: sticky</code> (which is pretty much everything since
          2017). No polyfills needed, no feature detection required - just
          works.
        </p>

        <h3>üì¶ Bundle Size Comparison</h3>
        <p>Let's put that 1.0KB into perspective:</p>
        <ul>
          <li><strong>Natural Sticky (top):</strong> 1.0KB minified</li>
          <li><strong>AOS (Animate On Scroll):</strong> ~13KB minified</li>
          <li><strong>Headroom.js:</strong> ~7KB minified</li>
          <li><strong>Sticky-js:</strong> ~4KB minified</li>
        </ul>

        <p>
          That's 87% smaller than the most popular alternatives, with better
          performance and more natural animations!
        </p>

        <p>
          Try scrolling up and down a few more times to really feel the
          difference. Notice how the header movement feels completely natural,
          like it's just part of the page content flowing with your scroll. No
          artificial timing, no disconnected animations - just pure, natural
          movement.
        </p>
      </div>
    </main>

    <!-- Natural Sticky Demo Script -->
    <script src="../dist/natural-sticky.top.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const header = document.querySelector('.sticky-header');
        if (header && window.naturalStickyTop) {
          window.naturalStickyTop(header);
        }
      });
    </script>

    <!-- Drag-to-scroll functionality for demo purposes -->
    <script src="drag-scroll.js"></script>
  </body>
</html>
